	.WIDTH	132
	.OPTION	B,D,L,T
	.MNOLIST

*
*COBRA CRAP  ********************TO BE REMOVED*************************
*
;	.DEF	O_COB,COBBUL,CKPLYR,CHKFREE
;O_COB	.EQU	0
;COBBUL	.EQU	0
;CKPLYR	.EQU	0
;CHKFREE	.EQU	0
*********************************TO BE REMOVED*************************
	
**************************************************************************
*	     CODE JANITORS: JAMIE BEGELMAN, KURT MAHAN, EUGENE P. JARVIS									
*	     COPYRIGHT (C) 1990 WILLIAMS ELECTRONICS GAMES INC.
*			 ALL RIGHTS RESERVED.				
*									
**************************************************************************
	.INCLUDE	"\VIDEO\SYS\GSP.INC"	;GSP ASSEMBLER EQUATES
	.INCLUDE	"\VIDEO\SYS\SYS.INC"	;Z UNIT SYSTEM EQUATES
	.INCLUDE	"\VIDEO\SYS\MACROS.HDR"	;MACROS DEFINITIONS
	.INCLUDE	MPROC.EQU
	.INCLUDE	LINK.EQU
	.INCLUDE	IMGTBL.GLO
*********************************************************
**************************************************************************
*									 *
*	DEFS AND REFS							 *
*									 *
**************************************************************************
	.REF	WDISTAB,SNDSND,INTIO,WARMSET,GET_AUD,STORE_AUDIT,WDOGDIS
	.DEF	POWERTST
	.DEF	CROSS_H,SW_CHK,CPU_CHK,COL_BARS,BURN_IN,STRNEW1

	.DEF	CIRCLE, HVLINE, STRING, RECTANGLE, POINT, DSCRCLR, INITCOLR

	.REF	SNDTST
	.REF	SYSCOPY
	.BSS	SWSET1,32		; FOR SWITCH TEST
	.BSS	SWSET2,32

	.BSS	DIPVAL,16

	.BSS	FORCEDIP,16		; FOR FORCING THE USE OF THE DIP
	.BSS	CERRORS,32
	.BSS	CPASSES,32
	.BSS	SCHANGE,16

	.TEXT
	.EVEN

**************************************************************************
*									 *
*	USEFUL MACROS							 *
*									 *
**************************************************************************
*
*	TIMED PAUSE
*
PAUSE	$MACRO TIME, REG
	 MOVI :TIME:, :REG:, L
LABEL?:  NOP
	 DSJS :REG:, LABEL?
	$END
*
*BIT SET
*	BSET	BIT# 0-31(KONSTANT OR REGISTER),REGISTER TO SET BIT IN
* NOTE: A14 IS DESTROYED, 'A' FILE REGISTERS ONLY
*
BSET	$MACRO	P1,R1
	MOVK	1,A14
	SLL	:P1:,A14
	OR	A14,:R1:
	$END
*
*FCALL - FUNCTION CALL WITHOUT USING THE SYSTEM STACK
*	FCALL	ROUTINE, BREG
*
FCALL	$MACRO NAME, BREG
	 MOVI  :NAME:, :BREG:, L
	 EXGPC :BREG:
	$END
*
*FRET - FUNCTION RETURN WITHOUT USING THE SYSTEM STACK
*	FCALL	ROUTINE, BREG
*
FRET	$MACRO BREG
	 EXGPC :BREG:
	$END

BUT_MAC	$MACRO	X,Y,RADIUS,COLOR,MASK,SHIFT,EXTEND
	.WORD	:X:	
	.WORD	:Y:
	.WORD	:RADIUS:
	.LONG	:COLOR:
	.LONG	:MASK:
	.WORD	:SHIFT:
	.WORD	:EXTEND:
	$END

STR_MAC	$MACRO	X,Y,STRING,COLOR,DIR
	.WORD	:X:	
	.WORD	:Y:
	.LONG	:STRING:
	.WORD	:COLOR:
	.WORD	:DIR:
	$END

VECMAC	$MACRO	COLOR,X1,Y1,X2,Y2
	.WORD	:COLOR:
	.WORD	:X1:
	.WORD	:Y1:
	.WORD	:X2:
	.WORD	:Y2:
	$END

DOTMAC	$MACRO	COLOR,X,Y
	.WORD	:COLOR:
	.WORD	:X:
	.WORD	:Y:
	$END

RECTMAC	$MACRO	COLOR,X,Y,W,H
	.WORD	:W:
	.WORD	:H:
	.WORD	:X:
	.WORD	:Y:
	.WORD	:COLOR:
	$END

CHIPMAC	$MACRO	NUM,X1,Y1,X2,Y2,X3,Y3,STRING,DIR,X4,Y4,STUFFED
	.WORD	:NUM:
	.WORD	:X1:
	.WORD	:Y1:
	.WORD	:X2:
	.WORD	:Y2:
	.WORD	:X3:
	.WORD	:Y3:
	.LONG	:STRING:
	.WORD	:DIR:
	.WORD	:X4:
	.WORD	:Y4:
	.WORD	:STUFFED:
	$END

CMNUM		EQU	0
CMLOC		EQU	CMNUM+16
CMXLOC		EQU	CMLOC
CMYLOC		EQU	CMLOC+16
CMSIZE		EQU	CMLOC+32
CMXSIZE		EQU	CMSIZE
CMYSIZE		EQU	CMSIZE+16
CMOFFSET	EQU	CMSIZE+32
CMSTRING	EQU	CMOFFSET+32
CMDIR		EQU	CMSTRING+32
CMPINLOC	EQU	CMDIR+16
CMSTUFFED	EQU	CMPINLOC+32
CMEND		EQU	CMSTUFFED+16
	

**************************************************************************
*									 *
* RAM_CHIP: MACRO DEFINES A RAM CHIP RECORD.				 *
*									 *
*	CHIP_NO    -- CHIP NUMBER					 *
*	WIDTH	   -- CHIP CELL SIZE IN BITS (MUST BE > 0)		 *
*	INTERLEAVE -- DISTANCE BETWEEN ADJACENT CELLS ON CHIP (IN BITS)	 *
*	START_ADDR -- ADDRESS OF FIRST CELL ON CHIP			 *
*	END_ADDR   -- ADDRESS OF LAST CELL ON CHIP			 *
*									 *
**************************************************************************

RAM_CHIP $MACRO TAB_LINK,CHIP_NO, WIDTH, INTERLEAVE, START_ADDR, END_ADDR	

	 .WORD	:WIDTH:
	 .WORD	:INTERLEAVE:
	 .WORD	:CHIP_NO:
	 .LONG	:START_ADDR:
	 .LONG	:END_ADDR:
	.LONG	:TAB_LINK:
	 $END

RAM_WDTH EQU	000H		    ; OFFSETS INTO RAM CHIP RECORD
RAM_ITLV EQU	010H
RAM_NMBR EQU	020H
RAM_SADR EQU	030H
RAM_EADR EQU	050H
RAM_LINK	EQU	070H
RAM_SIZE EQU	090H

ROM_CKSM	EQU	000H
ROM_WDTH	EQU	010H		    ; OFFSETS INTO ROM CHIP RECORD
ROM_ITLV	EQU	020H
ROM_NMBR	EQU	030H
ROM_SADR	EQU	040H
ROM_EADR	EQU	060H
ROM_LINK	EQU	080H
ROM_SIZE	EQU	0A0H

;****************************************************************************
;* ROM_CHIP: MACRO DEFINES A ROM CHIP RECORD.				    *
;*									    *
;*	 CHIP_NO    -- CHIP NUMBER					    *
;*	 WIDTH	    -- CHIP CELL SIZE IN BITS (MUST BE > 0)		    *
;*	 INTERLEAVE -- DISTANCE BETWEEN ADJACENT CELLS ON CHIP (IN BITS)    *
;*	 START_ADDR -- ADDRESS OF FIRST CELL ON CHIP			    *
;*	 END_ADDR   -- ADDRESS OF LAST CELL ON CHIP			    *
;*	 CHECK_SUM  -- DATAIO CHECK SUM FOR CHIP			    *
;****************************************************************************

ROM_CHIP $MACRO TAB_LINK,CHIP_NO, WIDTH, INTERLEAVE, START_ADDR, END_ADDR, CHECK_SUM

	.WORD	:CHECK_SUM:
	.WORD  :WIDTH:
	.WORD  :INTERLEAVE:
	.WORD  :CHIP_NO:
	.LONG  :START_ADDR:
	.LONG  :END_ADDR:
	.LONG	:TAB_LINK:

	 $END


RANDOM_SEED EQU 5A5A5A5Ah	       ; RAM TESTS: PSEUDO-RANDOM SEQUENCE
ZERO_EXTEND EQU 1Fh		       ; PARAMETERS
SIGN_EXTEND EQU 20h
PAL_SELECT  EQU 0FFDCH		       ; ENABLE VIDEO PALETTE MAP ACCESS

**************************************************************************
*									 *
*	POWERTST							 *
*									 *
*	POWERUP SELF TEST ROUTINES					 *
*									 *
*	ENTRY								 *
*		NOTHING							 *
*									 *
*	EXIT								 *
*		NOTHING							 *
*									 *
**************************************************************************
	.TEXT
BURN_IN
	DINT
	MOVI	STCKST-100H,SP,L
	JRUC	POWERTST1
CPU_CHK
POWERTST
	.IF	DEBUG
	JAUC	WARMSET
	.ENDIF
	DINT
	MOVI	STCKST,SP,L
POWERTST1
	SETF 16, 0, 0
	SETF 32, 0, 1

;	HALT DMA AND ENABLE CACHE

	CLR  A14
	MOVE A14, @DMACTRL
	MOVE A14, @CONTROL

*THESE STROBE EQUATES ARE FOR THE PINBALL SOUND CARD
RESETBIT	EQU	0FE00H	;THIS IS THE ^RESET BIT
MUSICBIT	EQU	0FD00H	;THIS IS THE YAMAHA SIDE STROBE
SOUNDBIT	EQU	0FD00H	;THIS IS THE SOUND SIDE STROBE
;	RESET SOUND BOARD
	MOVI	RESETBIT,A0	;HIT RESET BIT
	MOVE	A0,@SOUND
	MOVI	100,A0		;WAIT FOR IT TO CATCH
	DSJS	A0,$	
;	CLR	A0
	NOT	A0
	MOVE	A0,@SOUND

;	DISABLE VIDEO PALETTE RAMS, AUTOERASE AND ERROR LED

	MOVI 0FFFCH,A13
	MOVE A13,@SYSCTRL,W
;	MOVE	A13,@SYSCOPY

;	DISABLE WATCH DOG

;	 SETF 16,1,0			;SIGN EXTENSION ON FOR THIS
	MOVI	WDISTAB,A1	
	MOVK	1,A3
	MOVI	0FFFCH,A2
	MOVE	*A1+,A0,W		
WDOGSL
	OR	A2,A0	
	MOVE	A0,@SYSCTRL,W
	XOR	A3,A0
	MOVE	A0,@SYSCTRL,W
	MOVE	*A1+,A0,W
	SEXT	A0,W
	JRNN	WDOGSL

;	 SETF 16,0,0			;BACK OFF FOR BEGLEMAN SHIT
;	INITIALIZE IO REGISTERS
	FCALL	INTIO,B6

	CLR	B0
	MOVI	VRAMCHIPS, A14		; VERIFY COLOR/VIDEO RAMS
	FCALL	RAMCHECK, B5

;	ENABLE VIDEO PALETTE MAP ACCESS

	MOVI	PAL_SELECT, A13
	MOVE	A13,@SYSCTRL,W
	MOVI	PALCHIPS, A14		; VERIFY VIDEO PALETTE MAP RAMS
	FCALL	RAMCHECK, B5
	MOVE	B0,A12
	
;	DISABLE VIDEO PALETTE MAP ACCESS

	MOVI	0FFFCH,A13
	MOVE	A13,@SYSCTRL,W
	FCALL	INITCOLR, B5		  ; DISPLAY CPU BOARD
	FCALL	DSCRCLR,B6

	FCALL	CPUDRAW,B5
	MOVI	CPU,A10			; WE GOT THIS FAR, CPU MUST BE OK
	MOVI	1,A11
	FCALL	CHIPOUT,B5

	MOVI	VRAMTAB,A9
	FCALL	CHIPTABLE,B5		; PLOT OUT THE CHIP TABLE

	MOVE	A12,A12
	JRZ	PDMACK
PBADRAM
	MOVI	RAMBADMESS,A0
	JRUC	CPUBADM

;	MOVI	[128,130],A1
;	CLR	A2
;	MOVI	ROBO_RED,A3
;	FCALL	STRING,B6
;	JRUC	PCPUBAD

PDMACK
	MOVI	DMACMESS,A0
	MOVI	[128,130],A1
	CLR	A2
	MOVI	ROBO_YELLOW,A3
	FCALL	STRING,B6

	FCALL	DMACHECK,B5		; CHECK THE DMA
	MOVI	DMA,A10
	MOVE	A0,A11
	MOVE	A0,A12
	INC	A11			; GREEN/RED
	FCALL	CHIPOUT,B5

	MOVI	[128,130],A0
	MOVI	[10,260],A1
	MOVI	ROBO_BLACK,A2
	FCALL	RECTANGLE,B6

	MOVE	A12,A12
	JRZ	PSRAMCK		;MESSAGE FOR DMA BAD

	MOVI	DMABADMESS,A0
	JRUC	CPUBADM

;	MOVI	[128,130],A1
;	CLR	A2
;	MOVI	ROBO_RED,A3
;	FCALL	STRING,B6
;	JRUC	PCPUBAD


PSRAMCK
	MOVI	SRAMCHECK,A0
	MOVI	[128,130],A1
	CLR	A2
	MOVI	ROBO_YELLOW,A3
	FCALL	STRING,B6

;	MOVI	0FF3CH,A13			;SELECT PAGE ZERO CMOS
;	 MOVE	A13,@SYSCTRL,W

	MOVI	>200,A0				;UNLOCK CMOS
	MOVE	A0,@SECCHIP,W

	CLR	B0
	MOVI	SRAMCHIPS,A14		  ; VERIFY SCRATCH RAMS
	FCALL	RAMCHECK, B5
	MOVE	B0,A12

	MOVI	>300,A0				;LOCK CMOS
	MOVE	A0,@SECCHIP,W

	MOVI	0FFFCH,A13
	MOVE	A13,@SYSCOPY
	
;	MOVI	SRAMTAB,A9
;	FCALL	CHIPTABLE,B5

	MOVI	[128,130],A0
	MOVI	[10,260],A1
	MOVI	ROBO_BLACK,A2
	FCALL	RECTANGLE,B6

	MOVE	A12,A12
	JRNZ	PBADRAM
;
;	ROM CHANGES
;
PROMCK
	MOVI	ROMCMESS,A0
	MOVI	[128,130],A1
	CLR	A2
	MOVI	ROBO_YELLOW,A3
	FCALL	STRING,B6

	CLR	B0
	MOVI	PROMCHIPS,A14
	FCALL	ROMCHECK,B5
	MOVE	B0,B0
	JRNZ	PBADROM			; FOR NOW, WOOF WOOF

	CLR	B0			; CHECK ROMS
	MOVI	IROMCHIPS,A14
	FCALL	ROMCHECK,B5

	MOVE	B0,A12
	MOVI	[128,130],A0
	MOVI	[10,260],A1
	MOVI	ROBO_BLACK,A2
	FCALL	RECTANGLE,B6

	MOVE	A12,A12
	JRZ	PCPUGOOD

PBADROM
	MOVI	[128,130],A0
	MOVI	[10,260],A1
	MOVI	ROBO_BLACK,A2
	FCALL	RECTANGLE,B6
	MOVI	ROMBADMESS,A0
CPUBADM
	MOVI	[128,130],A1
	CLR	A2
	MOVI	ROBO_RED,A3
	FCALL	STRING,B6
;
; END OF ROM CHANGES
;

PCPUBAD
;	MOVI	CPUPAUSE,A0
;	MOVI	[143,130],A1
;	CLR	A2
;	MOVI	ROBO_RED,A3
;	FCALL	STRING,B6
PCPUBADL
	PAUSE  1200000H,B6			; GIVE THE GUY A GLIMPSE
	CMPI	STCKST,SP				;AUTO CYCLE ?
	JRNE	PCPUBADL			; YES, LOOP ON BAD
	JRUC	PCPURET

PCPUGOOD
	MOVI	CPUGOOD,A0
	MOVI	[143,130],A1
	CLR	A2
	MOVI	ROBO_GREEN,A3
	FCALL	STRING,B6

	PAUSE	600000H,B6			; GIVE THE GUY A GLIMPSE
PCPURET
	CMPI	STCKST,SP			;AUTO CYCLE ?
	JREQ	PCPURET1			; NOPE...
	CLR	A13
	SETF	16,1,0			;WORD SIGN EXTEND (FIELD 0)
	CALLA	SNDTST
	JRUC	BURN_IN

PCPURET1
	JAUC	WARMSET

WAIT	DSJS	B6,WAIT
WAIT1
	MOVE	@SWITCH,A0,L
	BTST	20,A0
	JREQ	WAIT1
	RETS

;*
;*DO CPU TEST, RETURNS TO CPUTESTR
;CPU_CHK:
;	DINT
;	CALLR	WDOGDIS
;	JAUC	CPUTEST
;*
;*CPU TEST RETURN POINT
;CPUTESTR:
;	MOVI	RT_RET,B0
;	JRUC	BTESTR
;*ROM BOARD TEST RETURN POINT
;ROMTESTR:
;	MOVI	ROM_RET,B0
;BTESTR:
;	MOVI	DIAG_PID,A1
;	CALLA	GETPRC			;CREATE PROCESS FOR RETURN
;	MOVI	INAMODE,A0
;	MOVE	A0,@GAMSTATE,W
;	JAUC	WARMSET
;*
;*CHECK THE ROM BOARD, THIS IS THE ONLY PLACE TO CALL ROMTEST
;*NO REGISTERS ARE PRESERVED
;CHECKROM:
;	PUSHST
;	DINT
;	MOVE	SP,@SPTEMP,L
;	CALLR	WDOGDIS
;	JAUC	ROMTEST
**************************************************************************
*									 *
*	MONITOR STUFF							 *
*									 *
**************************************************************************
CROSS_H
CONV_PLOT:
	MOVI	MON_RECS,A9
CPRLP1
	MOVE	*A9+,A2,W		; GET COLOR
	JRZ	CPRDONE
	MOVE	*A9+,A0,L		; START POINT
	MOVE	*A9+,A1,L		; DIMENSIONS
	FCALL	RECTANGLE,B6
	JRUC	CPRLP1
CPRDONE
	MOVI	MON_VECS,A9		; POINT AT VECTOR TABLE
CPVLP1
	MOVE	*A9+,A2,W		; GET COLOR
	JRZ	CPVDONE
	MOVE	*A9+,A0,L		; START POINT
	MOVE	*A9+,A1,L		; END POINT
	FCALL	HVLINE,B6
	JRUC	CPVLP1
CPVDONE
	MOVI	MON_DOTS,A9		; POINT AT DOT TABLE
CPDLP1
	MOVE	*A9+,A1,W		; GET COLOR
	JRZ	CPDDONE
	MOVE	*A9+,A0,L		; GET THE POINT
	FCALL	POINT,B6
	JRUC	CPDLP1
CPDDONE
	RETS
**************************************************************************
*									 *
*	MONITOR TEST DATA AREA						 *
*									 *
**************************************************************************

MON_VECS:
	VECMAC	ROBO_WHITE,004,004,390,004
	VECMAC	ROBO_WHITE,004,004,004,250
	VECMAC	ROBO_WHITE,004,250,390,250
	VECMAC	ROBO_WHITE,390,250,390,004
	VECMAC	ROBO_WHITE,060,005,060,250
	VECMAC	ROBO_WHITE,115,005,115,250
	VECMAC	ROBO_WHITE,170,005,170,250
	VECMAC	ROBO_WHITE,225,005,225,250
	VECMAC	ROBO_WHITE,280,005,280,250
	VECMAC	ROBO_WHITE,335,005,335,250
	VECMAC	ROBO_WHITE,005,54,390,54
	VECMAC	ROBO_WHITE,005,103,390,103
	VECMAC	ROBO_WHITE,005,152,390,152
	VECMAC	ROBO_WHITE,005,201,390,201
	.LONG	0

MON_RECS:
	VECMAC	ROBO_RED,182,000,030,005	; TOP
	VECMAC	ROBO_GREEN,182,005,030,006
	VECMAC	ROBO_RED,182,250,030,005	; BOTTOM
	VECMAC	ROBO_GREEN,182,244,030,006
	VECMAC	ROBO_RED,000,117,005,020	; LEFT
	VECMAC	ROBO_GREEN,005,117,006,020
	VECMAC	ROBO_RED,390,117,005,020	; RIGHT
	VECMAC	ROBO_GREEN,384,117,006,020
	.LONG	0

MON_DOTS:
	DOTMAC	ROBO_WHITE,032,029
	DOTMAC	ROBO_WHITE,087,029
	DOTMAC	ROBO_WHITE,142,029
	DOTMAC	ROBO_WHITE,197,029
	DOTMAC	ROBO_WHITE,252,029
	DOTMAC	ROBO_WHITE,307,029
	DOTMAC	ROBO_WHITE,362,029

	DOTMAC	ROBO_WHITE,032,078
	DOTMAC	ROBO_WHITE,087,078
	DOTMAC	ROBO_WHITE,142,078
	DOTMAC	ROBO_WHITE,197,078
	DOTMAC	ROBO_WHITE,252,078
	DOTMAC	ROBO_WHITE,307,078
	DOTMAC	ROBO_WHITE,362,078

	DOTMAC	ROBO_WHITE,032,127
	DOTMAC	ROBO_WHITE,087,127
	DOTMAC	ROBO_WHITE,142,127
	DOTMAC	ROBO_WHITE,197,127
	DOTMAC	ROBO_WHITE,252,127
	DOTMAC	ROBO_WHITE,307,127
	DOTMAC	ROBO_WHITE,362,127

	DOTMAC	ROBO_WHITE,032,176
	DOTMAC	ROBO_WHITE,087,176
	DOTMAC	ROBO_WHITE,142,176
	DOTMAC	ROBO_WHITE,197,176
	DOTMAC	ROBO_WHITE,252,176
	DOTMAC	ROBO_WHITE,307,176
	DOTMAC	ROBO_WHITE,362,176

	DOTMAC	ROBO_WHITE,032,225
	DOTMAC	ROBO_WHITE,087,225
	DOTMAC	ROBO_WHITE,142,225
	DOTMAC	ROBO_WHITE,197,225
	DOTMAC	ROBO_WHITE,252,225
	DOTMAC	ROBO_WHITE,307,225
	DOTMAC	ROBO_WHITE,362,225
	.LONG	0

PRIMARY_COLORS:

	RECTMAC	ROBO_RED,0,0,395,255
	RECTMAC	ROBO_GREEN,0,0,395,255
	RECTMAC	ROBO_BLUE,0,0,395,255
	.LONG	0

COLOR_BARS:
				
	RECTMAC	ROBO_BLACK,   0, 0, 49, 16
	RECTMAC	ROBO_BLACK,  49, 0, 49, 16
	RECTMAC	ROBO_BLACK,  98, 0, 49, 16
	RECTMAC	ROBO_BLACK, 147, 0, 49, 16
	RECTMAC	ROBO_BLACK, 196, 0, 49, 16	
	RECTMAC	ROBO_BLACK, 245, 0, 49, 16
	RECTMAC	ROBO_BLACK, 294, 0, 49, 16
	RECTMAC	ROBO_BLACK, 343, 0, 49, 16
	.LONG	0



**************************************************************************
*									 *
*	COLORBAR							 *
*									 *
**************************************************************************
COL_BARS
COLORBAR:

	 MOVI	INTENSITIES_START, A0, L
	 MOVI	COLRAM+100H,A1, L

	 MOVK	16, A2			   ; 5 BITS / COLOR
	 MOVK	8, A6			  ; # COLOR BARS
CB3
	ADDI	>F00,A1		;STEP TO NEXT PALETTE
	MOVE	*A0+, A3		   ; STARTING COLOR
	 MOVE	*A0+, A4		   ; COLOR DECREMENT

	MOVE A2, A5

CB4	MOVE A3, *A1+
	SUB  A4, A3
	DSJS A5, CB4
	DSJS A6, CB3

;	=========================
;	| DISPLAY COLOR BARS	|
;	=========================

	CLR	A14
	MOVE	A14,@DMAGO		; HALT THE DMA
	MOVI	0101H,A14
	MOVE	A14,A8

	MOVI COLOR_BARS,  A3, L        ; COLOR BAR TABLE
	MOVI [16,0], A13, L		; POSITION INCRMENT
	MOVI	101H,A12
	MOVK   16,  A11 		; # INTENSITIES / BAR
	MOVK	8,A6			;THIS MANY BARS
CB6
	CLR A2			     ; STARTING COLOR
	MOVE	*A3+,A1,L
	JRZ	CB8
	MOVE	A8,@DMACMAP,W		;STUFF PALETTE
	MOVE	*A3+,A0,L
	ADDK	16,A3
	MOVE	A11,A10
CB7
	FCALL RECTANGLE, B6
	ADD   A13, A0
	ADD   A12, A2
	DSJS  A10, CB7
	ADD	A14,A8			;NEXT PALETTE PLEASE
	DSJ	A6,CB6

CB8
	CLR	A14
	MOVE	A14,@DMACMAP,W
	RETS


INTENSITIES_START:

	.WORD 03E0H		   ; GREEN
	.WORD 0040H		   ; BUMP GREEN

	.WORD 7C00H		   ; RED
	.WORD 0800H		   ; BUMP RED

	.WORD 001FH		   ; BLUE
	.WORD 0002H		   ; BUMP BLUE

	.WORD 0000H		   ; BLACK
	.WORD 0000H		   ; BUMP BLACK

	.WORD 7FFFH		   ; WHITE
	.WORD 0842H		   ; BUMP WHITE

	.WORD 7FE0H		   ; YELLOW
	.WORD 0840H		   ; BUMP YELLOW

	.WORD 7C1FH		   ; PURPLE
	.WORD 0802H		   ; BUMP PURPLE

	.WORD 03FFH		   ; CYAN
	.WORD 0042H		   ; BUMP CYAN

	.LONG	0

**************************************************************************
*									 *
*	SWITCHTEST							 *
*									 *
*	DRAW OUT THE ROBO SWITCHES -- A PRETTY PICTURE			 *
*									 *
*	ENTRY								 *
*		NOTHING							 *
*									 *
*	EXIT								 *
*		NOTHING							 *
*									 *
**************************************************************************

;DONEMASK		EQU	00100000H			;TEST SWITCH
DONEMASK	EQU	00240000H		; P1 + P2 START
	.BSS	DONECNT,32		; FOR SWITCH TEST
SW_CHK
SWITCHTEST:
	MMTM	SP,A12,A13
;	CALLA	WDOGDIS
	MOVI	>10,A13
	MOVE	A13,@DONECNT,L
	CLR	A13			; THE HOLD ME REGISTER
	MOVE	A13,@SWSET1,L
	MOVE	A13,@SWSET2,L
	MOVI	BUT_TABLE,A9
	CLR	A10
	CALLR	BUT_PLOT		; PLOT SOME BUTTONS
	MOVI	JOY_TABLE,A9
	CALLR	JOY_PLOT		; PLOT THE JOYSTICKS
	MOVI	STR_TABLE,A9
	CALLR	STR_PLOT		; PLOT THE STRINGS
	MOVI	00B90000H,A0
	MOVI	00B90190H,A1
	MOVI	ROBO_WHITE,A2
	FCALL	HVLINE,B6		; DRAW LITTLE WHITE LINE
SDLOOP
	MMFM	SP,A12,A13
	SLEEP	1
	MMTM	SP,A12,A13

	MOVE	@SWITCH,A10,L		; GRAB ME A SWITCH REGISTER
	NOT	A10
	MOVE	A10,A0
	ANDI	DONEMASK,A0
	CMPI	DONEMASK,A0,L		; CHECK FOR DONE
	JRNZ	SDGO
	MOVE	@DONECNT,A0,L		;REQUIRE A CERTAIN TIME
	DEC	A0
	MOVE	A0,@DONECNT,L
	JRNE	SDGO
	MMFM	SP,A12,A13
	RETP
SDGO
	MOVE	@SWSET1,A11,L
	CMP	A11,A10			; CHECK FOR CHANGES
	JRZ	SDCK2
	MOVE	A10,@SWSET1,L
	MOVE	@SWITCH+32,A10,L
	NOT	A10
	SLL	24,A10
	SRL	24,A10
;	ANDI	0FFH,A10
	JRUC	SDPRC1
;	MOVE	A10,@SWSET2,L
;	JRUC	SDPROC
SDCK2
	MOVE	@SWITCH+32,A10,L
	NOT	A10
	SLL	24,A10
	SRL	24,A10
;	ANDI	0FFH,A10
	MOVE	@SWSET2,A11,L
	CMP	A11,A10
	JRZ	SDLOOP
SDPRC1
	MOVE	A10,@SWSET2,L
SDPROC
	CLR	A0
	MOVE	A0,@SCHANGE,W

	MOVI	BUT_TABLE,A9
	CALLR	BUT_PLOT
	MOVI	JOY_TABLE,A9
	CALLR	JOY_UPDATE		; UPDATE THE JOYSTICK INFO

	MOVE	@SCHANGE,A0,W
	JRZ	SDLOOP

	MOVI	0FD80H,A0
	MOVE	A0,@SOUND,W
	MOVI	0FF80H,A0
	MOVE	A0,@SOUND,W
	JRUC	SDLOOP
*
*DIP SWITCH TEST
*
DIPTEST
	MOVI	>C8,A12
	MOVI	DIPTAB,A9
	CALLR	STR_PLOT		; PLOT THE STRINGS
DIPL
	MOVE	@VCOUNT,A1,W		; CUT BEAM INTERFERENCE
	CMPI	200,A1
	JRLS	DIPL

	MOVB	@SWITCH+>30,A10
;	SLL	24,A10
	MOVI	>60009E,A1
	MOVK	1,A2
	CALLR	DIPSUB

	MOVB	@SWITCH+>38,A10
;	SLL	24,A10
	MOVI	>600152,A1
	CALLR	DIPSUB
	MOVE	A12,A12
	JRN	DIPL1
	DEC	A12
	JRUC	DIPL
DIPL1
	MOVE	@SWITCH,A0,L
	BTST	20,A0
	JREQ	DIPL
	RETS

DIPSUB
		MOVK	8,A11
DIPTST1L
	MOVI	ROBO_BLACK,A3		;ERASE OLD BUGGERS
	MOVI	DIPON,A0		
	CALLR	STRNEW
	MOVI	DIPOFF,A0
	CALLR	STRNEW
	MOVI	ROBO_WHITE,A3
	MOVI	DIPON,A0		
	SRL	1,A10
	JRNC	DIPTST1
	MOVI	DIPOFF,A0
DIPTST1
	CALLR	STRNEW
	SUBI	>00E,A1
	DSJS	A11,DIPTST1L
	RETS
	
**************************************************************************
*									 *
*	JOY_MESS							 *
*									 *
*	PLOT THE STATUS OF A JOYSTICK AROUND A CIRCLE			 *
*									 *
*	ENTRY								 *
*		A9	CENTER OF STICK CIRCLE				 *
*		A10	BUTTON MASK					 *
*		A11	COLOR						 *
*									 *
*	EXIT								 *
*		NOTHING							 *
*									 *
**************************************************************************
	
JOY_MESS:
	MOVI	JJJTAB,A8
	MOVK	4,A7
JML
	MOVI	ROBO_BLACK,A3
	SRL	1,A10
	JRNC	JM1
	MOVE	A11,A3			; SET COLOR
	MOVK	1,A14
	MOVE	A14,@SCHANGE,W
JM1
	MOVE	*A8+,A0,L
	MOVE	A9,A1			; CIRCLE CENTER
	MOVB	*A8,A2			;X CORRECTION
	ADDK	8,A8
	ADD	A2,A1
	MOVB	*A8,A2			;Y CORRECTION
	ADDK	8,A8
	SLL	16,A2
	ADD	A2,A1
	CLR	A2			; DIRECTION
	CALLR	STRNEW
	DSJS	A7,JML
	RETS
*
*JOYSTICK MESSAGE TABLE
*
JJJTAB
	.LONG	UPMESS
	.BYTE	-7,-27

	.LONG	DOWNMESS
	.BYTE	-20,20

	.LONG	LEFTMESS
	.BYTE	-48,-5

	.LONG	RIGHTMESS
	.BYTE	20,-5



**************************************************************************
*									 *
*	BUT_PLOT							 *
*									 *
*	PLOT A BUTTON TABLE ON THE SCREEN				 *
*									 *
*	ENTRY								 *
*		A9	POINTS TO BUTTON TABLE LIST			 *
*		A10	SETTINGS OF THE SWITCH REGISTER			 *
*									 *
*	EXIT								 *
*		NOTHING							 *
*									 *
**************************************************************************

BUT_PLOT:
	MOVE	*A9,A1,L		; XY LOC
	JRZ	BPDONE
	ADDI	32,A9			
	MOVE	*A9,A0,W		; RADIUS
	ADDI	16,A9
	MOVE	*A9,A6,L		; COLOR
	ADDI	32,A9
	MOVE	*A9,A11,L		; GET MASK
	ADDI	32,A9			; MASK
	ADDI	16,A9			; SHIFT COUNT
	MOVE	*A9,A8,W		; JAMMA EXTEND-O-BIT
	JRZ	BPLOW
	MOVE	@SWSET2,A10,L
	JRUC	BPAND
BPLOW
	MOVE	@SWSET1,A10,L
BPAND
	ADDI	16,A9
	AND	A10,A11			; MASK OFF SOMETHING USEFUL
	JRZ	BPHOLLOW
	ADDI	CFILL,A6		; MASK IN THE FILL BITS
	JRUC	BPCIRC
BPHOLLOW
	MMTM	SP,A0,A1,A6
	MOVI	ROBO_BLACK,A6
	ADDI	CFILL,A6
	FCALL	CIRCLE,B6
	MMFM	SP,A0,A1,A6
	JRUC	BPCIRC2
BPCIRC
	MOVK	1,A14
	MOVE	A14,@SCHANGE,W
BPCIRC2
	FCALL	CIRCLE,B6
	JRUC	BUT_PLOT
BPDONE
	RETS

**************************************************************************
*									 *
*	JOY_PLOT							 *
*									 *
*	PLOT A BUTTON TABLE ON THE SCREEN				 *
*									 *
*	ENTRY								 *
*		A9	POINTS TO BUTTON TABLE LIST			 *
*									 *
**************************************************************************

JOY_PLOT:
	MOVE	*A9,A1,L		; XY LOC
	JRZ	JPDONE
	ADDI	32,A9			
	MOVE	*A9,A0,W		; RADIUS
	ADDI	16,A9
	MOVE	*A9,A6,L		; COLOR
	ADDI	96,A9
	FCALL	CIRCLE,B6
	JRUC	JOY_PLOT
JPDONE
	RETS

**************************************************************************
*									 *
*	JOY_UPDATE							 *
*									 *
*	UPDATE ALL THE STICK INFORMATION				 *
*									 *
*	ENTRY								 *
*		A9	JOYSTICK TABLE POINTER				 *
*		A10	SWITCH INFORMATION				 *
*									 *
*	EXIT								 *
*		NOTHING							 *
*									 *
**************************************************************************

JOY_UPDATE:
	MOVE	*A9,A1,L		; XY LOC
	JRZ	JUDONE
	ADDI	32,A9			
	MOVE	*A9,A0,W		; RADIUS
	ADDI	16,A9
	MOVE	*A9,A11,L		; COLOR
	ADDI	32,A9
	MOVE	*A9,A6,L		; MASK
	ADDI	32,A9
	MOVE	*A9,A7,W		; SHIFT COUNT
	ADDI	16,A9
	MOVE	*A9,A8,W		; EXTEND-O-BIT FOR JAMMA
	JRZ	JULOW
	MOVE	@SWSET2,A10,L
	JRUC	JUAND
JULOW
	MOVE	@SWSET1,A10,L
JUAND
	ADDI	16,A9
	AND	A10,A6			; MASK OFF JOYSTICK BITS
	NOT	A7
	ADDK	1,A7
	SRL	A7,A6			; ZERO BASE THE LITTLE SUCKER
	MMTM	SP,A9,A10,A8,A7
	MOVE	A1,A9			; CENTER OF STICK HERE
	MOVE	A6,A10			; BUTTON MASK
	CALLR	JOY_MESS
	MMFM	SP,A9,A10,A8,A7
	JRUC	JOY_UPDATE
JUDONE
	RETS


**************************************************************************
*									 *
*	STR_PLOT							 *
*									 *
*	PLOT A STRING TABLE ON THE SCREEN				 *
*									 *
*	ENTRY								 *
*		A9	POINTS TO STRING TABLE LIST			 *
*									 *
**************************************************************************

STR_PLOT:
	MOVE	*A9,A1,L		; XY LOC
	JRZ	STDONE
	ADDI	32,A9			
	MOVE	*A9,A0,L		; STRING PTR
	ADDI	32,A9
	MOVE	*A9,A3,W		; COLOR
	ADDI	16,A9
	MOVE	*A9,A2,W		; DIRECTION
	ADDI	16,A9
	FCALL	STRING,B6
	JRUC	STR_PLOT
STDONE
	RETS

CFILL	EQU	0FFFF0000H

;
;	FORMAT
;
;	X,Y,RADIUS,COLOR,MASK,SHIFT COUNT ( FOR JOYSTICK STUFF ), EXTENDBIT
;
BUT_TABLE:
	BUT_MAC	107,65,10,ROBO_RED,00040000H,0,0	; P1 START
	BUT_MAC	293,65,10,ROBO_BLUE,00200000H,0,0	; P2 START
	BUT_MAC	260,199,10,ROBO_GREEN,00080000H,0,0	; SLAM
	BUT_MAC	260,222,10,ROBO_GREEN,00100000H,0,0	; TEST
	BUT_MAC	260,245,10,ROBO_GREEN,01000000H,0,0	; VIDEO FREEZE
	BUT_MAC 30,207,10,ROBO_GREEN,00010000H,0,0	; COIN LEFT (1)
	BUT_MAC	120,207,10,ROBO_GREEN,00800000H,0,0	; COIN CENTER (3)
	BUT_MAC	75,207,10,ROBO_GREEN,00020000H,0,0	; COIN RIGHT (2)
	BUT_MAC	165,207,10,ROBO_GREEN,02000000H,0,0	; FOURTH COIN (4)
	BUT_MAC	214,207,10,ROBO_GREEN,00400000H,0,0	; SERVICE CREDIT
	.LONG	0

JOY_TABLE
	BUT_MAC	65,130,15,CFILL+ROBO_RED,0000000FH,0,0	; P1 MOVE
	BUT_MAC	162,130,15,CFILL+ROBO_RED,00000F0H,4,0	; P1 FIRE
	BUT_MAC	243,130,15,CFILL+ROBO_BLUE,0000F00H,8,0	; P2 MOVE
	BUT_MAC	335,130,15,CFILL+ROBO_BLUE,000F000H,12,0	; P2 FIRE
	.LONG	0


STR_TABLE:
	STR_MAC	140,15,STSTART,ROBO_YELLOW,0	; SMASH TV SWITCH MESSAGE
	STR_MAC	80,82,P1START,ROBO_RED,0	; P1 START
	STR_MAC	262,82,P2START,ROBO_BLUE,0	; P2 START
	STR_MAC	40,167,P1MOVE,ROBO_RED,0	; P1 MOVE
	STR_MAC	135,167,P1FIRE,ROBO_RED,0	; P1 FIRE
	STR_MAC	216,167,P2MOVE,ROBO_BLUE,0	; P2 MOVE
	STR_MAC	315,167,P2FIRE,ROBO_BLUE,0	; P2 FIRE
	STR_MAC	275,196,SLAM,ROBO_GREEN,0	; SLAM
	STR_MAC	275,219,TEST,ROBO_GREEN,0	; TEST SWITCH
	STR_MAC	275,242,VIDEO,ROBO_GREEN,0	; VIDEO FREEZE

;	STR_MAC	10,222,LEFTMESS,ROBO_GREEN,0	; LEFT COIN
;	STR_MAC	46,222,CENTER,ROBO_GREEN,0	; CENTER COIN
;	STR_MAC	100,222,RIGHTMESS,ROBO_GREEN,0	; RIGHT COIN
;	STR_MAC	139,222,FOURTH,ROBO_GREEN,0
	STR_MAC	15,222,CBUTMESS,ROBO_GREEN,0

	STR_MAC	15,233,COINMESS,ROBO_GREEN,0
	STR_MAC	193,222,SERVICE1,ROBO_GREEN,0	; SERVICE CREDIT
	STR_MAC	197,233,SERVICE2,ROBO_GREEN,0	; SERVICE CREDIT
	STR_MAC	100,35,GETOUT1,ROBO_WHITE,0	; GET OUT MESSAGE 1
	.LONG	0
DIPTAB
	STR_MAC	>90,>20,DIPMES0,ROBO_WHITE,0	; DIP SWITCH TEST
	STR_MAC	>68,>3C,DIPMES1,ROBO_GREEN,0	; DIP SWITCH 1
	STR_MAC	>114,>3C,DIPMES2,ROBO_GREEN,0	; DIP SWITCH 2
	STR_MAC	>3C,>50,DIPMES18,ROBO_WHITE,0	; 1-8
	STR_MAC	>F0,>50,DIPMES18,ROBO_WHITE,0	; 1-8
	.LONG	0
DIPMES0
	.STRING	"DIP SWITCH TEST",0
DIPMES1
	.STRING	"DS1",0
DIPMES18
	.STRING "1 2 3 4 5 6 7 8",0
DIPMES2
	.STRING	"DS2",0
DIPON
	.STRING	"ON",0
DIPOFF
	.STRING	"OFF",0
GETOUT1
	.STRING	"P1 START AND P2 START TO EXIT",0
;	.STRING	"TEST SWITCH OFF TO EXIT",0
	.EVEN

STSTART
	.STRING	"TOTAL CARNAGE SWITCHES",0
	.EVEN

P1START
	.STRING	"P1 START",0
	.EVEN
P2START
	.STRING	"P2 START",0
	.EVEN

LEFTMESS
	.STRING	"LFT",0
	.EVEN
RIGHTMESS
	.STRING	"RT",0
	.EVEN
UPMESS
	.STRING	"UP",0
	.EVEN
DOWNMESS
	.STRING	"DOWN",0
	.EVEN

P1MOVE
	.STRING	"P1 MOVE",0
	.EVEN
P1FIRE
	.STRING	"P1 FIRE",0
	.EVEN
P2MOVE
	.STRING	"P2 MOVE",0
	.EVEN
P2FIRE
	.STRING	"P2 FIRE",0
	.EVEN

COINMESS
	.STRING	"COIN   COIN   COIN  COIN",0
	.EVEN

CBUTMESS .STRING "LFT 1  RT 2    3      4",0
	.EVEN

;CENTER
;	.STRING	"CENTER",0
;	.EVEN
;FOURTH
;	.STRING	"FOURTH",0
;	.EVEN

SERVICE1
	.STRING	"SERVICE",0
	.EVEN
SERVICE2
	.STRING	"CREDIT",0
	.EVEN
SLAM
	.STRING	"SLAM - TILT",0
	.EVEN
TEST
	.STRING	"TEST",0
	.EVEN
VIDEO
	.STRING	"VIDEO FREEZE",0
	.EVEN

DMACMESS
	.STRING	"CHECKING CUSTOM",0
	.EVEN
DMABADMESS
	.STRING	"CUSTOM CHIP U99 BAD",0
	.EVEN

ROMCMESS
	.STRING	"CHECKING ROMS",0
	.EVEN
ROMBADMESS
	.STRING	"ROM CHIPS BAD",0
	.EVEN

RAMBADMESS
	.STRING	"RAM CHIPS BAD",0
	.EVEN

CPUGOOD
	.STRING	"CPU BOARD OK",0
	.EVEN

CPUWAIT1
CPUPAUSE
	.STRING	"PRESS ANY BUTTON",0
	.EVEN

**************************************************************************
*									 *
*	CPUDRAW								 *
*									 *
*	PLOT THE CPU BOARD AND DRAW ALL THE CHIPS			 *
*									 *
*	ENTRY								 *
*		B5	RETURN ADDRESS					 *
*									 *
*	EXIT								 *
*		NOTHING							 *
*									 *
**************************************************************************

CPUDRAW:
	MOVI	CPU_VECS,A9		; POINT AT VECTOR TABLE
CPUDLP1
	MOVE	*A9+,A2,W		; GET COLOR
	JRZ	CPUD1
	MOVE	*A9+,A0,L		; START POINT
	MOVE	*A9+,A1,L		; END POINT
	FCALL	HVLINE,B6
	JRUC	CPUDLP1
CPUD1
	MOVE	B5,A13
	FCALL	CHIPPLOT,B5		; PLOT ALL THE CHIPS
	MOVE	A13,B5
	FRET	B5

**************************************************************************
*									 *
*	CHIPTABLE							 *
*									 *
*	UPDATE A LIST OF CHIPS, BASED ON THEIR VALUES IN A12		 *
*									 *
*	ENTRY								 *
*		A9	POINTER TO TABLE				 *
*		A12	LIST OF ON/OFF BITS				 *
*		B5	RETURN ADDRESS					 *
*									 *
*	EXIT								 *
*		NOTHING							 *
*									 *
**************************************************************************

CHIPTABLE:
	MOVE	B5,A14
CTABLOOP
	MOVE	*A9+,A10,L		; GET POINTER TO CHIP RECORD
	JRZ	CTABDONE
	MOVK	1,A11
	MOVE	*A10(CMNUM),A0,W	; GET THE BIT NUMBER
	BTST	A0,A12			; CHECK BIT NUMBER
	JRZ	CTABL2
	MOVK	2,A11
CTABL2
	FCALL	CHIPOUT,B5
	JRUC	CTABLOOP

CTABDONE
	MOVE	A14,B5
	FRET	B5
	
**************************************************************************
*									 *
*	CHIPPLOT							 *
*									 *
*	PLOT OUT THE CHIP LIST						 *
*									 *
*	ENTRY								 *
*		B5	RET VALUE					 *
*									 *
*	EXIT								 *
*		NOTHING							 *
**************************************************************************

CHIPPLOT:
	MOVE	B5,A14
	MOVI	CPU_CHIPS,A10
CPPLOTLOOP
	CLR	A11
	MOVE	*A10,A0,L
	JRZ	CPPLOTDONE
	FCALL	CHIPOUT,B5
	ADDI	CMEND,A10
	JRUC	CPPLOTLOOP

CPPLOTDONE
	MOVE	A14,B5
	FRET	B5
	
**************************************************************************
*									 *
*	CHIPOUT								 *
*									 *
*	ACTUALLY PLOT THE CHIP						 *
*									 *
*	ENTRY								 *
*		A10	POINTS TO CHIP TO PLOT				 *
*		A11	COLOR OF CHIP					 *
*				00 = OUTLINE				 *
*				01 = GREEN				 *
*				02 = RED				 *
*				03 = GREY				 *
*									 *
*	EXIT								 *
*		A10	IS INTACT					 *
*									 *
**************************************************************************
		
CHIPOUT:
	MOVE	*A10(CMLOC),A5,L	; CHIP OUTLINE
	MOVE	A5,A6
	MOVE	A5,A7
	MOVE	A5,A8
	MOVE	*A10(CMXSIZE),A0,W
	ADD	A0,A6
	ADD	A0,A7
	MOVE	*A10(CMYSIZE),A0,W
	SLL	16,A0
	ADD	A0,A7
	ADD	A0,A8
	MOVE	A5,A0
	MOVE	A6,A1
	MOVI	ROBO_WHITE,A2
	FCALL	HVLINE,B6
	MOVE	A6,A0
	MOVE	A7,A1
	MOVI	ROBO_WHITE,A2
	FCALL	HVLINE,B6
	MOVE	A8,A0
	MOVE	A7,A1
	MOVI	ROBO_WHITE,A2
	FCALL	HVLINE,B6
	MOVE	A5,A0
	MOVE	A8,A1
	MOVI	ROBO_WHITE,A2
	FCALL	HVLINE,B6
;
	MOVE	*A10(CMSTUFFED),A0,W	; CHECK FOR STUFFED
	JRNZ	CONOSTUF
	MOVK	3,A11			; WANT IT GREY, DUDE

CONOSTUF
	MOVE	A11,A11			; CHECK FOR FILLING THE CHIP
	JRZ	CONOFILL
	MOVE	*A10(CMLOC),A0,L
	ADDI	00010001H,A0
	MOVE	*A10(CMSIZE),A1,L
	SUBI	00010001H,A1		; GET INTERNAL AREA
	MOVE	A11,A2
	SLL	4,A2
	ADDI	CHIPCOLORS,A2
	MOVE	*A2,A2,W		; GET ME A COLOR
	FCALL	RECTANGLE,B6
CONOFILL
	MOVE	*A10(CMPINLOC),A1,L	; PIN LOCATION
	MOVE	A5,A0
	ADD	A1,A0
	MOVI	ROBO_WHITE,A1
	FCALL	POINT,B6

	MOVE	*A10(CMSTRING),A0,L	; CHIP TEXT
	MOVE	A5,A1
	MOVE	*A10(CMOFFSET),A2,L
	ADD	A2,A1
	MOVE	*A10(CMDIR),A2,W
	MOVI	ROBO_BLACK,A3
	MOVE	A11,A11			; CHECK FOR COLOR
	JRNZ	COBLACK
	MOVI	ROBO_WHITE,A3
COBLACK
	FCALL	STRING,B6
	FRET	B5

CHIPCOLORS:
	.WORD	ROBO_BLACK
	.WORD	ROBO_GREEN
	.WORD	ROBO_RED
	.WORD	ROBO_GREY

**************************************************************************
*									 *
*	DMACHECK							 *
*									 *
*	CHECK THE DMA OUT						 *
*									 *
*	ENTRY								 *
*		B5	RETURN ADDRESS					 *
*									 *
*	EXIT								 *
*		A0	DMA STATUS					 *
*				0 = GOOD				 *
*				1 = BAD					 *
*									 *
**************************************************************************

DMACHECK
	MOVI	 [1,448],A14,L	       ; BLOW OUT TRADEMARK
	MOVE	 A14,@DMAHSIZE,1

	CLR	A14
	MOVE	A14,@DMAOFFST		; OFFSET
	MOVE	A14,@DMACONST, 0		; CONSTANT
	MOVE	A14,@DMAHORIZ, 1		; CLEAR DESTINATION ADDRESS
	MOVE	A14,@DMASAGL, 1
	MOVI	257,A14
	MOVE	A14,@DMAVERT,W		; NEAT NEW VERTICAL ADDRESS

	MOVI	0505H,A14
	MOVE	A14,@DMACMAP, 0

	MOVI	8003H,A14		; USE IMAGE ROM - WRITE ALWAYS
	MOVE	A14,@DMACTRL, 0

	MOVI	7FFFH,A14
DMACWAIT
	MOVE	@DMACTRL,A0,W	;DMA BUSY?
	BTST	15,A0
	JREQ	DMADONE
	DSJS	A14,DMACWAIT
	JRUC	DMACBAD		; DMA TIMED OUT

DMADONE
	CLR	A0		; GET BACK TO A REAL PALETTE
	MOVE	A0,@DMACMAP,0
	MOVI	0101000H,A0	; LOCATION
	MOVI	2000000H,A1	; DMA LOGO LOCATION
	MOVI	448,A2		; NUMBER OF BYTES TO COMPARE
DMACLOOP	
	MOVB	*A0,A3
	SLL	28,A3
	SRL	28,A3
;	ANDI	0FH,A3		; MASK, SINCE IT IS 4 BITS, DUDE!
	MOVB	*A1,A4
	SLL	28,A4
	SRL	28,A4
;	ANDI	0FH,A4		; WELL, WE KNOW WHAT IT SHOULD BE, BUT...
	ADDK	8,A0
	ADDK	8,A1
	CMP	A3,A4
	JRNZ	DMACBAD
	DSJS	A2,DMACLOOP
;
;	NOW CHECK OUT THE PALETTE END OF THINGS
;
	MOVI  PAL_SELECT, A13
	MOVE  A13,@SYSCTRL,W	; ENABLE PALETTE

	MOVI	0101000H,A0	; LOCATION
	MOVI	224,A2		; NUMBER OF BYTES TO COMPARE
DMACLOOP2
	MOVE	*A0+,A3,W
	ANDI	0F0FH,A3
	CMPI	0505H,A3
	JRNZ	DMACBAD
	DSJS	A2,DMACLOOP2
	CLR	A0
	JRUC	DMACRET
DMACBAD
	CLR	A0		; GET BACK TO A REAL PALETTE
	 MOVE	A0,@DMACTRL,W
	MOVE	A0,@DMACMAP,W
	MOVK	1,A0
DMACRET
	MOVI	0FFFCH,A13
	MOVE	A13,@SYSCTRL,W
	MOVE	A0,A0
	FRET	B5

**************************************************************************
*									 *
*	RAMCHECK							 *
*									 *
*	CHECK A BANK OF RAM, GIVEN A STARTING TABLE ADDRESS		 *
*									 *
*	ENTRY								 *
*		A14	POINTER TO RAM TABLE				 *
*		B5	RETURN ADDRESS					 *
*									 *
*	EXIT								 *
*		B0	LIST OF ERRORS					 *
*									 *
**************************************************************************

RAMCHECK:
	SETF 16, 0, 0
	SETF 32, 0, 1

;	SNAG NEXT CHIP RECORD

RAMLOOP:
	CLR	B2
	MOVE	*A14(RAM_SADR),A12,L	; STARTING ADDRESS
	MOVE	*A14(RAM_EADR),A13,L	; ENDING ADDRESS
	MOVE	*A14(RAM_ITLV),A11,W	; INTERLEAVE
	MOVE	*A14(RAM_WDTH),A10,W	; WIDTH

;	CELL COUNT

	SUB  A12, A13			; (END-START)/INTERLEAVE+1
	DIVU A11, A13
	INC  A13

;	SET FIELD SIZES

	MOVE A11, A9			; FS1 = INTERLEAVE
	ANDI ZERO_EXTEND, A9
	EXGF A9, 1

	MOVE A10, A9			; FS0 = WIDTH
	ANDI ZERO_EXTEND, A9
	EXGF A9, 0

;	FILL IN ASCENDING ORDER

	MOVE A13, A9			; XEROX COUNT
	MOVE A12, A8			; XEROX START

	MOVI RANDOM_SEED, A7, L
	CLR  A5

RAC1:	SLA  1, A7			; GENERATE A PSEUDO
	JRV  RAC2			; RANDOM NUMBER
	ORI  2, A7
RAC2:	MOVE A7, A6
	ADDC A5, A6

	MOVE A6, *A8+, 1		; WRITE

	DSJS A9, RAC1

;	READBACK IN ASCENDING ORDER

	MOVE A13, A9			; XEROX COUNT
	MOVE A12, A8			; XEROX START

	MOVI RANDOM_SEED, A7, L

RAC3:	SLA  1, A7			; GENERATE A PSEUDO
	JRV  RAC4			; RANDOM NUMBER
	ORI  2, A7
RAC4:	MOVE A7, A6
	ADDC A5, A6

	MOVE *A8+, A4, 1		; READ

	ZEXT  A6
	ZEXT  A4

	CMP A6, A4
	JRZ RAC5
;
;	GOT AN ERROR HERE
;
	SETF 16, 0, 0			; RESET FIELDS
	SETF 32, 0, 1
	MOVE	*A14(RAM_NMBR),A4,W	; GET BIT NUMBER TO SET
	MOVE	A4,B1
	MOVK	1,B2
	SLL	B1,B2
	OR	B2,B0			; SET THAT BIT
	JRUC RAC6			; BREAK !!

RAC5:	DSJS A9, RAC3

RAC6:	SETF 16, 0, 0			; RESET FIELDS
	SETF 32, 0, 1
;
;	B1 SHOULD BE ZERO IF THE CHIP IS COOL HERE
;
	MOVE	*A14(RAM_LINK),A10,L
	JRZ	RAMNOPLOT
	MOVK	1,A11
	MOVE	B2,B2
	JRZ	RAMPLOT
	MOVK	2,A11
RAMPLOT
	MOVE	B5,A9			; I HOPE THIS ONE IS SAFE!
	MOVE	B0,A13
	FCALL	CHIPOUT,B5
	MOVE	A13,B0
	MOVE	A9,B5

RAMNOPLOT
	ADDI	RAM_SIZE,A14		; ADVANCE TO NEXT GUY
	MOVE	*A14,A7,W
	JRNZ	RAMLOOP			; HERE WE GO AGAIN
	FRET	B5

**************************************************************************
*									 *
*	ROM STUFF							 *
*									 *
**************************************************************************

ROMCHECK:

ROMLOOP	
	CLR	B2
	MOVE	*A14(ROM_CKSM),A13,L	; CHECK TO SEE IF ROM SOCKET THERE
	JRZ	ROMEMPTY
	CLR	A8			; CHECKSUM

	MOVE	*A14(ROM_SADR),A12,L	; STARTING ADDRESS
	MOVE	*A14(ROM_EADR),A13,L	; ENDING ADDRESS
	MOVE	*A14(ROM_ITLV),A11,W	; INTERLEAVE
	MOVE	*A14(ROM_WDTH),A10,W	; WIDTH
	JRZ	PROG_ROM
;
;	SUM UP A GIVEN IMAGE ROM -- THIS IS ONLY FOR 4BIT SYSTEMS
;
	SUB	A12,A13			; ( EADDR - SADDR ) / 32 + 1
	MOVK	32,A0
	DIVU	A0,A13
	INC	A13

	SLL	1,A11			;ADJUST SHIFT FOR TYPE
	NEG	A11
;
;
RCILP
	MOVE	*A12+,A7,L
	
	SRL	A11,A7

	MOVE	A7,A0
	ANDI	00000003H,A0		; BITS 1-0
	MOVE	A0,A1			; FIRST TWO BITS
	MOVE	A7,A0
	ANDI	00000300H,A0
	SRL	6,A0
	OR	A0,A1			; BITS 3-2
	MOVE	A7,A0
	ANDI	000030000H,A0
	SRL	12,A0
	OR	A0,A1			; BITS 5-4
	MOVE	A7,A0
	ANDI	03000000H,A0
	SRL	18,A0
	OR	A0,A1			; BITS 7-6

RCILDONE
	ADD	A1,A8
	DSJ	A13,RCILP
	JRUC	ROMCKCK

PROG_ROM
	SUB	A12,A13			; ( EADDR - SADDR ) / 32 + 1
***	MOVK	8,A0
***	DIVU	A0,A13
	SRL	4,A13
	INC	A13
RCPLP
	MOVB	*A12,A7
	SLL	24,A7
	SRL	24,A7
	ADDK	16,A12
	ADD	A7,A8
	DSJS	A13,RCPLP

ROMCKCK
	MOVE	*A14(ROM_CKSM),A7,W
	ZEXT	A7
	ZEXT	A8
****	ANDI	0FFFFH,A7
	CMP	A7,A8
	JRZ	ROMRELOOP
	MOVE	*A14(ROM_NMBR),A4,W	; GET BIT NUMBER TO SET
	MOVE	A4,B1
	MOVK	1,B2
	SLL	B1,B2
	OR	B2,B0			; SET THAT BIT
ROMRELOOP
	MOVE	*A14(ROM_LINK),A10,L
	JRZ	ROMNOPLOT
	MOVK	1,A11
	MOVE	B2,B2
	JRZ	ROMPLOT
	MOVK	2,A11
ROMPLOT
	MOVE	B5,A9			; I HOPE THIS ONE IS SAFE!
	MOVE	B0,A13
	FCALL	CHIPOUT,B5
	MOVE	A13,B0
	MOVE	A9,B5

ROMNOPLOT
	ADDI	ROM_SIZE,A14
	JRUC	ROMLOOP
;
ROMEMPTY
	FRET	B5


;****************************************************************************
;* INITCOLR: INITIALIZE COLORS; ROUTINE LOADS PALETTE 0 WITH THE COLOR	    *
;*	     PALETTE USED BY DIAGNOSTIC TESTS.				    *
;****************************************************************************

INITCOLR:
;

	MOVI	COLRAM,A0,L		; PALETTE LOCATION
	MOVI	DIAGP,A1,L
	MOVE	*A1+,A2,W		; LENGTH OF PALETTE
LPLP1
	MOVE	*A1+,*A0+,W
	DSJS	A2,LPLP1		; KEEP ON CHUGGIN, BABY

	CLR  A14
	MOVE A14, @CMAPSEL

	FRET B5
;****************************************************************************
;* POINT: FUNCTION DISPLAYS A POINT OF ANY COLOR.			    *
;*									    *
;*	      ENTRY: A0 = XY SCREEN ADDRESS OF THE POINT		    *
;*		     A1 = COLOR VALUE					    *
;*		     B6 = RETURN ADDRESS				    *
;*									    *
;*	      USES:  A0, A1, B2, B3, B4, B6, B10			    *
;****************************************************************************

POINT:

	MOVI SCRN_PTCH, DPTCH
	CLR  OFFSET

	LMO  DPTCH, B10
	MOVE B10, @CONVDP

	PIXT A1, *A0.XY

	FRET B6

;****************************************************************************
;* RECTANGLE: FUNCTION DISPLAYS A RECTANGLE OF ANY COLOR.		    *
;*									    *
;*	      ENTRY: A0 = XY SCREEN ADDRESS OF UPPER LEFT CORNER	    *
;*		     A1 = XY RECTANGLE DIMENSIONS			    *
;*		     A2 = COLOR VALUE					    *
;*									    *
;*		     B6 = RETURN ADDRESS				    *
;*									    *
;*	      USES:  A0, A1, A2, B2, B3, B4, B6, B7, B9, B10		    *
;****************************************************************************

RECTANGLE:

	MOVI SCRN_PTCH, DPTCH
	CLR  OFFSET

	LMO  DPTCH, B10
	MOVE B10, @CONVDP

	MOVE A2, COLOR1
	MOVE A0, DADDR
	MOVE A1, DYDX

	FILL  XY

	FRET B6

;****************************************************************************
;* LINE: FUNCTION DRAWS HORIZONTAL OR VERTICAL LINES OF ANY COLOR.	    *
;*									    *
;*	      ENTRY: A0 = BEGINNING XY SCREEN ADDRESS			    *
;*		     A1 = ENDING XY SCREEN ADDRESS			    *
;*		     A2 = COLOR VALUE					    *
;*									    *
;*		     B6 = RETURN ADDRESS				    *
;*									    *
;*	      USES:  A0, A1, A2, A3, A4, B3, B4, B6, B9, B10		    *
;****************************************************************************

HVLINE:

;	CLR	A0
;	CLR	A1
;HVL1
;	MOVE	A2,*A0+
;	MOVI	100,A3
;LLL	DSJS	A3,LLL
;	DSJS	A1,HVL1


	MOVI SCRN_PTCH, DPTCH
	CLR  OFFSET

	LMO  DPTCH, B10
	MOVE B10, @CONVDP

	MOVE A2, COLOR1

	MOVK  1H, A2			; DRAV DX: ASSUME HORIZONTAL LINE

	MOVE  A0, A3			; DETERMINE (P2 > P1) OR (P2 < P1)
	CVXYL A3, A3

	MOVE  A1, A4
	CVXYL A4, A4

	CMP  A3, A4			; IF (P2 < P1) ~(INCREMENT)
	JRP  $100

	NEG  A2 			; INCREMENT IS A SIGNED WORD
	ZEXT A2, 0

$100:	CMPXY A0, A1			; IF VERTICAL LINE
	JRZ   $110			; DRAV DX -> DRAV DY
	SLL   16, A2
	
$110:	DRAV  A2, A0			; DRAW LINE
	CMPXY A0, A1
	JRNN  $110
	JRNZ  $110

	FRET B6

;****************************************************************************
;* STRING: FUNCTION DISPLAYS AN ASCIZ STRING OF ANY COLOR EITHER VERTICALLY *
;*	   OR HORIZONTALLY.						    *
;*									    *
;*	      ENTRY: A0 = STARTING STRING ADDRESS			    *
;*		     A1 = XY SCREEN ADDRESS				    *
;*		     A2 = DIRECTION					    *
;*		     A3 = COLOR 					    *
;*									    *
;*		     B6 = RETURN ADDRESS				    *
;*									    *
;*	      USES: A0 - A6, B0 - B4, B6 - B14				    *
;****************************************************************************
STRNEW1
	MMTM	SP,A1,A2,A3,A4,A5,A6
	FCALL	STRING,B6
	MMFM	SP,A1,A2,A3,A4,A5,A6
	RETS
STRNEW
	MMTM	SP,A0
	CALLR	STRNEW1
	MMFM	SP,A0
	RETS
STRING:

	MOVI SCRN_PTCH, DPTCH
	CLR  OFFSET

	LMO  DPTCH, B10
	MOVE B10, @CONVDP

	MOVE A3, COLOR1 
	CLR  COLOR0


$200:	MOVB *A0, A4		       ; GET CHARACTER
	JRZ  $230			; QUIT IFF NULL

	ADDK	8,A0
	SUBK 32, A4			; GET POINTER TO CHARACTER HEADER
	SLL  3, A4
	ADDI SYSFONT,A4,L
	MOVB	*A4,A4
	SLL	5,A4
	ADDI	T2_SP,A4
	MOVE	*A4+,A5 	       ; CHAR DIMENSIONS
	MOVE	A5,A6			  ; SPLIT UP BYTE
	SLL	12,A6			  ;SHIFT UP HEIGHT TO Y
	SLL	28,A5			  ;STRIP AWAY HEIGHT
	SRL	28,A5
	MOVY	A6,A5
	RL	16,A5
	 MOVE	A5,DYDX

	CLR  A6 			; A6 = CHAR WIDTH
	MOVX A5, A6

	ADDK 7, A6			; ROUND UP WIDTH TO INTEGRAL NUMBER
	SRL  3, A6			; OF BYTES = SOURCE PITCH
	SLL  3, A6
	MOVE A6, SPTCH

	MOVE *A4,A6		       ; CHAR DATA
	ADDI	CBASE,A6
	MOVE  A6, SADDR
	
	MOVE A1, DADDR

	PIXBLT B,XY

	CLR  A6
	MOVE A2, A2
	JRZ  $210

	MOVY A5, A6			 ; A1 += (CHAR HEIGHT + SPACING)
	SRL  16, A6			 ; DIRECTION = DOWN
	ADDK 1H, A6
	SLL  16, A6
	ADD  A6, A1
	JRUC $200
	
$210:	MOVX A5, A6			 ; A1 += (CHAR WIDTH + SPACING)
	ADDK 2H, A6			 ; DIRECTION = RIGHT
	ADD  A6, A1
	JRUC $200

$230:						;  SETF 16, 1, 0
	FRET B6

;STRINGCENTER:
;	SETF	8, 0, 0
;	CLR	A1
;	MOVE	A0,A2
;SPLLOOP
;	MOVE	*A0+, A4		; GET THE CHAR
;	 JRZ	SPLEND			; END OF STRING
;
;	 SUBK	32, A4			   ; GET POINTER TO CHARACTER HEADER
;	 SLL	5H, A4
;	 ADDI	SYSFONT, A4, L
;	 MOVE	*A4, A4, 1
;
;	 MOVE	*A4+, A5, 1		   ; CHAR DIMENSIONS
;	 MOVE	A5, DYDX
;
;	 CLR	A6			   ; A6 = CHAR WIDTH
;	 MOVX	A5, A6
;
;	 ADDK	7, A6			   ; ROUND UP WIDTH TO INTEGRAL NUMBER
;	 SRL	3, A6			   ; OF BYTES = SOURCE PITCH
;	 SLL	3, A6
;	
;	MOVX	A5, A6			    ; A1 += (CHAR WIDTH + SPACING)
;	 ADDK	2H, A6			    ; DIRECTION = RIGHT
;	 ADD	A6, A1
;	 JRUC	SPLLOOP
;
;SPLEND
;	SETF	16, 1, 0
;	MOVE	A2,A0			; RESTORE STRING ADDRESS
;	SRL	1,A1
;	MOVI	200,A2
;	SUB	A1,A2
;	MOVE	A2,A1
;	 FRET	B6
;****************************************************************************
;* CIRCLE: FUNCTION DRAWS OUTLINE OR FILLED CIRCLES.			    *
;*									    *
;*	 ENTRY: A0 = radius						    *
;*		A1 = center  (Y:X)					    *
;*		A6 = <00:15> = color					    *
;*		A6 = <15:31> = fill: 0=no fill, 1=fill			    *
;*									    *
;*	 USES:	A0 - A8, B0, B10					    *
;****************************************************************************

CIRCLE:

	movi  plot8,a7		     ; assume no fill
	btst  16,a6
	jrz   CIRC0
	movi  fill4,a7
CIRC0:
	movi  SCRN_PTCH,DPTCH	     ; Restore screen pitch and convdp
	MOVI  13h,B10		     ; THIS IS FASTER
	MOVE  B10,@CONVDP
	MOVE  A6,COLOR1
	movi  [1,0],DYDX		 ; Y width always 1

	clr   a2		      ; x = 0
	move  a0,a3		      ; y = r
	move  a0,a4
	sll   1,a4
	subk  3,a4
	neg   a4		     ; d = 3 - 2*r
cloop:
	cmp   a3,a2		     ; if x > y, we are done
	jrgt  done

	MOVE  A7, B0		     ; PLOT ROUTINE
	EXGPC B0

	move  a2,a5		     ; x -> a5
	btst  31,a4
	jrz   dpos		     ; branch if d is positive

;	      d negative

	sll   2,a5		     ; 4*x -> a5
	addk  6,a5		     ; 4*x+6 -> a5
	jruc  cont

;	      d positive

dpos:		

	sub   a3,a5		     ; x-y -> a5
	sll   2,a5		     ; 4*(x-y) -> a5
	addk  10,a5		     ; 4*(x-y)+10 -> a5
	subk  1,a3		     ; y = y - 1

cont:
	add   a5,a4		     ; d = d + a5
	addk  1,a2		     ; x = x + 1
	jruc  cloop

done:	FRET B6

plot8:
	move  a3,a5
	neg   a5		   ; -y into a5; +y in a3
	sll   16,a5
	sll   16,a3
	movx  a2,a5		   ; a3 = (y:x)
	movx  a2,a3		   ; a5 = (-y:x)

	movk  2,a8
put4:
	move  a1,a0		   ; center (Y:X) in a0
	addxy a3,a0		   ; (cx+x),(cy+y)
	pixt  a6,*a0.XY
	move  a1,a0		   ; center (Y:X) in a0
	addxy a5,a0		   ; (cx+x),(cy-y)
	pixt  a6,*a0.XY
	move  a1,a0		   ; center (Y:X) in a0
	subxy a3,a0		   ; (cx-x),(cy-y)
	pixt  a6,*a0.XY
	move  a1,a0		   ; center (Y:X) in a0
	subxy a5,a0		   ; (cx-x),(cy+y)
	pixt  A6,*a0.XY
	rl    16,a3
	rl    16,a5		   ; transpose x and y	
	dsj   a8,put4
	sra   16,a3		   ; restore y

	FRET B0

fill4:
	move  a2,b10		   ; x
	sll   1,b10		   ; 2x
	movx  b10,DYDX		   ; delta x = 2x
	move  a3,a5
	neg   a5		   ; -y into a5      +y in a3
	sll   16,a5
	sll   16,a3
	movx  a2,a5		   ; a3 = (y:x)
	movx  a2,a3		   ; a5 = (-y:x)
	movk  2,a8
put2:	
	move  a1,a0
	subxy a5,a0
	move  a0,DADDR
	fill  XY

	move  a1,a0
	subxy a3,a0
	move  a0,DADDR
	fill  XY
	rl    16,a3		   ; a3 = (x:y)
	rl    16,a5		   ; transpose x and y	
	clr   a6
	subxy a5,a6
	move  a6,a5		   ; a5 = (-x:y)
	move  a3,b10		   ; y
	sll   1,b10		   ; 2y
	movx  b10,DYDX		   ; delta x = 2y
	dsj   a8,put2
	sra   16,a3		   ; restore y

	FRET B0
*
*SCRCLR - CLEAR ENTIRE BIT MAP
*	USES:B2,B3,B4	CALL WITH B6
DSCRCLR
	CLR	B2
DSWRITE
	CLR	B3
	MOVE	B3,@DMACMAP,0
	MOVI	SCREEN,B3,L
	MOVI	(SCRNE-SCREEN)/32,B4,L
SCRLP	MOVE	B2,*B3+,L
	DSJS	B4,SCRLP
	FRET	B6

**************************************************************************
*									 *
*	CPU BOARD INFORMATION						 *
*									 *
**************************************************************************

CPU_VECS:		
	VECMAC	ROBO_WHITE,5,15,390,15		; BOARD OUTLINE
	VECMAC	ROBO_WHITE,390,15,390,254
	VECMAC	ROBO_WHITE,5,254,390,254
	VECMAC	ROBO_WHITE,5,15,5,100
	VECMAC	ROBO_WHITE,5,100,15,100
	VECMAC	ROBO_WHITE,15,100,15,115
	VECMAC	ROBO_WHITE,5,115,15,115
	VECMAC	ROBO_WHITE,5,115,5,135
	VECMAC	ROBO_WHITE,5,135,15,135
	VECMAC	ROBO_WHITE,15,135,15,138
	VECMAC	ROBO_WHITE,5,138,15,138
	VECMAC	ROBO_WHITE,5,138,5,215
	VECMAC	ROBO_WHITE,5,215,15,215
	VECMAC	ROBO_WHITE,15,215,15,230
	VECMAC	ROBO_WHITE,5,230,15,230
	VECMAC	ROBO_WHITE,5,230,5,254
	.LONG	0

CPUXBASE	EQU	5
CPUYBASE	EQU	5


CPU_CHIPS:
CRAM1	CHIPMAC	0,100,25,20,40,7,12,CNAME5,1,2,2,1	; COLOR RAM
CRAM2	CHIPMAC	1,100,70,20,40,7,8,CNAME23,1,2,2,1	; COLOR RAM

VRAM1	CHIPMAC	2,200,25,15,35,5,5,CNAME10,1,2,2,1	; BANK 1 VIDEO RAM
VRAM2	CHIPMAC	3,217,25,15,35,5,5,CNAME11,1,2,2,1
VRAM3	CHIPMAC	4,234,25,15,35,5,5,CNAME12,1,2,2,1
VRAM4	CHIPMAC	5,251,25,15,35,5,5,CNAME13,1,2,2,1
VRAM5	CHIPMAC	6,268,25,15,35,5,5,CNAME14,1,2,2,1
VRAM6	CHIPMAC	7,285,25,15,35,5,5,CNAME15,1,2,2,1

VRAM7	CHIPMAC	8,200,70,15,35,5,5,CNAME28,1,2,2,1	; BANK 2 VIDEO RAM
VRAM8	CHIPMAC	9,217,70,15,35,5,5,CNAME29,1,2,2,1
VRAM9	CHIPMAC	10,234,70,15,35,5,5,CNAME30,1,2,2,1
VRAM10	CHIPMAC	11,251,70,15,35,5,5,CNAME31,1,2,2,1
VRAM11	CHIPMAC	12,268,70,15,35,5,5,CNAME32,1,2,2,1
VRAM12	CHIPMAC	13,285,70,15,35,5,5,CNAME33,1,2,2,1

CPU	CHIPMAC	0,330,80,35,35,8,14,CNAME36,0,3,3,1	; CPU
DMA	CHIPMAC	0,320,175,45,40,12,18,CNAME99,0,42,3,1	; DMA

PROM1	CHIPMAC	0,90,167,20,40,7,8,CNAME89,1,2,2,1	; PROGRAM ROM 1
PROM2	CHIPMAC	1,90,210,20,40,7,3,CNAME105,1,2,2,1	; PROGRAM ROM 2

IROM1	CHIPMAC	1,130,167,20,40,7,8,CNAME90,1,2,2,0	; IMAGE ROM
IROM2	CHIPMAC	2,152,167,20,40,7,8,CNAME91,1,2,2,0	; IMAGE ROM
IROM3	CHIPMAC	3,174,167,20,40,7,8,CNAME92,1,2,2,0	; IMAGE ROM
IROM4	CHIPMAC	4,196,167,20,40,7,8,CNAME93,1,2,2,0	; IMAGE ROM

IROM5	CHIPMAC	5,228,167,20,40,7,8,CNAME95,1,2,2,1	; IMAGE ROM
IROM6	CHIPMAC	6,250,167,20,40,7,8,CNAME96,1,2,2,1	; IMAGE ROM
IROM7	CHIPMAC	7,272,167,20,40,7,8,CNAME97,1,2,2,1	; IMAGE ROM
IROM8	CHIPMAC	8,294,167,20,40,7,8,CNAME98,1,2,2,0	; IMAGE ROM

IROM9	CHIPMAC	9,130,210,20,40,7,3,CNAME106,1,2,2,1	; IMAGE ROM
IROM10	CHIPMAC	10,152,210,20,40,7,3,CNAME107,1,2,2,1	; IMAGE ROM
IROM11	CHIPMAC	11,174,210,20,40,7,3,CNAME108,1,2,2,1	; IMAGE ROM
IROM12	CHIPMAC	12,196,210,20,40,7,3,CNAME109,1,2,2,0	; IMAGE ROM

IROM13	CHIPMAC	13,228,210,20,40,7,3,CNAME111,1,2,2,1	; IMAGE ROM
IROM14	CHIPMAC	14,250,210,20,40,7,3,CNAME112,1,2,2,1	; IMAGE ROM
IROM15	CHIPMAC	15,272,210,20,40,7,3,CNAME113,1,2,2,1	; IMAGE ROM
IROM16	CHIPMAC	16,294,210,20,40,7,3,CNAME114,1,2,2,0	; IMAGE ROM

SRAM1	CHIPMAC	0,30,130,15,35,5,5,CNAME66,1,2,2,1	; SCRATCH PAD
SRAM2	CHIPMAC	1,47,130,15,35,5,5,CNAME67,1,2,2,1	; SCRATCH PAD
SRAM3	CHIPMAC	2,64,130,15,35,5,5,CNAME68,1,2,2,1	; SCRATCH PAD
SRAM4	CHIPMAC	3,81,130,15,35,5,5,CNAME69,1,2,2,1	; SCRATCH PAD

*CHIPMAC	$MACRO	NUM,X1,Y1,X2,Y2,X3,Y3,STRING,DIR,X4,Y4,STUFFED
CMOSRAM	CHIPMAC	4,100,115,20,40,7,8,CNAME49,1,2,2,1	; CMOS RAM
	.LONG	0

VRAMTAB	.LONG	CRAM1,CRAM2
	.LONG	VRAM1,VRAM2,VRAM3,VRAM4,VRAM5,VRAM6
	.LONG	VRAM7,VRAM8,VRAM9,VRAM10,VRAM11,VRAM12
	.LONG	0
PROMTAB	.LONG	PROM1,PROM2
	.LONG	0
IROMTAB	.LONG	IROM1,IROM2,IROM3,IROM4
	.LONG	IROM5,IROM6,IROM7,IROM8
	.LONG	IROM9,IROM10,IROM11,IROM12
	.LONG	IROM13,IROM14,IROM15,IROM16
	.LONG	0
SRAMTAB	.LONG	SRAM1,SRAM2,SRAM3,SRAM4,CMOSRAM
	.LONG	0
	
CNAME5
	.STRING	"U5",0
	.EVEN
CNAME10	
	.STRING	"U10",0
	.EVEN
CNAME11	
	.STRING	"U11",0
	.EVEN
CNAME12	
	.STRING	"U12",0
	.EVEN
CNAME13	
	.STRING	"U13",0
	.EVEN
CNAME14	
	.STRING	"U14",0
	.EVEN
CNAME15	
	.STRING	"U15",0
	.EVEN
CNAME23
	.STRING	"U23",0
	.EVEN
CNAME28
	.STRING	"U28",0
	.EVEN
CNAME29
	.STRING	"U29",0
	.EVEN
CNAME30
	.STRING	"U30",0
	.EVEN
CNAME31
	.STRING	"U31",0
	.EVEN
CNAME32
	.STRING	"U32",0
	.EVEN
CNAME33
	.STRING	"U33",0
	.EVEN
CNAME36
	.STRING	"U36",0
	.EVEN
CNAME49
	.STRING	"U49",0
	.EVEN
CNAME66
	.STRING	"U66",0
	.EVEN
CNAME67
	.STRING	"U67",0
	.EVEN
CNAME68
	.STRING	"U68",0
	.EVEN
CNAME69
	.STRING	"U69",0
	.EVEN
CNAME89	
	.STRING	"U89",0
	.EVEN
CNAME90	
	.STRING	"U90",0
	.EVEN
CNAME91	
	.STRING	"U91",0
	.EVEN
CNAME92
	.STRING	"U92",0
	.EVEN
CNAME93	
	.STRING	"U93",0
	.EVEN
CNAME95	
	.STRING	"U95",0
	.EVEN
CNAME96	
	.STRING	"U96",0
	.EVEN
CNAME97	
	.STRING	"U97",0
	.EVEN
CNAME98	
	.STRING	"U98",0
	.EVEN
CNAME99
	.STRING	"U99",0
	.EVEN
CNAME105
	.STRING	"U105",0
	.EVEN
CNAME106
	.STRING	"U106",0
	.EVEN
CNAME107
	.STRING	"U107",0
	.EVEN
CNAME108
	.STRING	"U108",0
	.EVEN
CNAME109
	.STRING	"U109",0
	.EVEN
CNAME111
	.STRING	"U111",0
	.EVEN
CNAME112
	.STRING	"U112",0
	.EVEN
CNAME113
	.STRING	"U113",0
	.EVEN
CNAME114
	.STRING	"U114",0
	.EVEN
CNAME115
	.STRING	"U115",0
	.EVEN



**************************************************************************
*									 *
*	RAM CHIP DATA							 *
*									 *
**************************************************************************

;
;	MAKE SURE THESE TABLES CORRESPOND WITH THE STUFF ABOVE
;
VRAMCHIPS:

;	COLOR RAMS

	RAM_CHIP 0,0, 8, 16, 1800008H, 180FFF8H
	RAM_CHIP 0,1, 8, 16, 1800000H, 180FFF0H

;	VIDEO RAMS
	RAM_CHIP 0,10, 4, 32, 0000018H, 01FFFF8H	; U30 ( 24 - 27 )
	 RAM_CHIP 0,11, 4, 32, 0000010H, 01FFFF0H	; U31 ( 16 - 19 )
	RAM_CHIP 0,12, 4, 32, 0000008H, 01FFFE8H	; U32 (  8 - 11 )
	RAM_CHIP 0,13, 4, 32, 0000000H, 01FFFE0H	; U33 (  0 - 3	)

;RAM_CHIP $MACRO TAB_LINK,CHIP_NO, WIDTH, INTERLEAVE, START_ADDR, END_ADDR	
	RAM_CHIP 0,2, 2, 32, 000001CH, 01FFFFCH	; U10 ( 28 - 29 )
	RAM_CHIP 0,3, 2, 32, 0000014H, 01FFFF4H	; U11 ( 20 - 21 )
	RAM_CHIP 0,8, 2, 32, 000000CH, 01FFFECH	; U28 ( 12 - 13 )
	RAM_CHIP 0,9, 2, 32, 0000004H, 01FFFE4H	; U29 (  4 - 5	)

	.LONG	0

PALCHIPS:

;	VIDEO PALETTE RAMS

	RAM_CHIP 0,4, 4, 32, 0000018H, 01FFFF8H	; U12 (  24 - 27 )
	RAM_CHIP 0,5, 4, 32, 0000010H, 01FFFF0H	; U13 (  16 - 19  )
	RAM_CHIP 0,6, 4, 32, 0000008H, 01FFFE8H	; U14 (  8 - 11 )
	RAM_CHIP 0,7, 4, 32, 0000000H, 01FFFE0H	; U15 (  0 - 3	)

;RAM_CHIP $MACRO TAB_LINK,CHIP_NO, WIDTH, INTERLEAVE, START_ADDR, END_ADDR	

	RAM_CHIP 0,2, 2, 32, 000001EH, 01FFFFEH	; U10 ( 30 - 31 )
	RAM_CHIP 0,3, 2, 32, 0000016H, 01FFFF6H	; U11 ( 22 - 23 )
	RAM_CHIP 0,8, 2, 32, 000000EH, 01FFFEEH	; U28 ( 14 - 15 )
	RAM_CHIP 0,9, 2, 32, 0000006H, 01FFFE6H	; U29 (  6 - 7	)

	.LONG	0

;	SCRATCH RAMS

SRAMCHECK
	.STRING	"CHECKING SCRATCH RAMS",0
	.EVEN

SRAMCHIPS
	RAM_CHIP SRAM4,3, 4, 16, 1000000H, 10FFFF0H	; U69 (  0 - 3	)
	RAM_CHIP SRAM3,2, 4, 16, 1000004H, 10FFFF4H	; U68 (  4 - 7	)
	RAM_CHIP SRAM2,1, 4, 16, 1000008H, 10FFFF8H ; U67 (  8 - 11 )
	RAM_CHIP SRAM1,0, 4, 16, 100000CH, 10FFFFCH	; U66 ( 12 - 15 )
;RAM_CHIP $MACRO TAB_LINK,CHIP_NO, WIDTH, INTERLEAVE, START_ADDR, END_ADDR	
CMOSCHIP
	RAM_CHIP CMOSRAM,4, 8, 16, 1407FE0H, 1407FF0H ; U49 (  0 - 7  )
	.LONG	0

PROMCHIPS
;ROM_CHIP $MACRO TAB_LINK,CHIP_NO, WIDTH, INTERLEAVE, START_ADDR, END_ADDR, CHECK_SUM
	ROM_CHIP PROM1,0,0,0, 0FFE00008H, 0FFFFFFF8H, >3FC5	; U89
	ROM_CHIP PROM2,1,0,0, 0FFE00000H, 0FFFFFFF0H, >7E70	; U105
	.LONG	0
		.WORD	>C03A,>818F					   ;CHECKSUM ADJUST

IROMCHIPS
	.EVEN
	ROM_CHIP IROM13,13, 8, 0,  2000000H, 23FFFFFH, 06FC0H	; U111
	ROM_CHIP IROM5, 5, 8, 1,  2000000H, 23FFFFFH, 0D367H	; U95
	ROM_CHIP IROM9, 9, 8, 2,  2000000H, 23FFFFFH, 0A9DEH	; U106

	ROM_CHIP IROM14,14, 8, 0,  2400000H, 27FFFFFH, 0373EH	; U112
	ROM_CHIP IROM6, 6, 8, 1,  2400000H, 27FFFFFH, 0BD14H	; U96
	ROM_CHIP IROM10,10, 8, 2,  2400000H, 27FFFFFH, 01C6CH	; U107

	ROM_CHIP IROM15,15, 8, 0,  2800000H, 2BFFFFFH, 06525H	; U113
	ROM_CHIP IROM7, 7, 8, 1,  2800000H, 2BFFFFFH, 00C91H	; U97
	ROM_CHIP IROM11,11, 8, 2,  2800000H, 2BFFFFFH, 014F6H	; U108

;ROM_CHIP $MACRO TAB_LINK,CHIP_NO, WIDTH, INTERLEAVE, START_ADDR, END_ADDR, CHECK_SUM

	.LONG	0		; FORCE IT TO STOP HERE

;****************************************************************************
;* SYSFONT: SYSTEM FONT; MODULE DEFINES THE FONT USED WITH SYSTEM	    *
;*	    DIAGNOSTICS.						    *
;****************************************************************************

; ===========================
; | DYDX CHAR DIMENSIONS    |
; | POINTER TO XY CHAR DATA |
; ===========================

T2_SP:
   .WORD    048h
   .word    I2_SP-CBASE

T2_MN:
   .WORD    088h
   .WORD    I2_MN-CBASE

T2_PER:
   .WORD	    028H
   .WORD	   I2_PER-CBASE

T2_SLASH:
   .WORD	    068H
   .WORD	    I2_SLASH-CBASE

T2_00:
   .WORD    068h
   .WORD    I2_00-CBASE

T2_11:
   .WORD    068h
   .WORD    I2_11-CBASE

T2_22:
   .WORD    068h
   .WORD    I2_22-CBASE

T2_33:
   .WORD    068h
   .WORD    I2_33-CBASE

T2_44:
   .WORD    068h
   .WORD    I2_44-CBASE

T2_55:
   .WORD    068h
   .WORD    I2_55-CBASE

T2_66:
   .WORD    068h
   .WORD    I2_66-CBASE

T2_77:
   .WORD    068h
   .WORD    I2_77-CBASE

T2_88:
   .WORD    068h
   .WORD    I2_88-CBASE

T2_99:
   .WORD    068h
   .WORD    I2_99-CBASE

T2_AA:
   .WORD    068h
   .WORD    I2_AA-CBASE

T2_BB:
   .WORD    068h
   .WORD    I2_BB-CBASE

T2_CC:
   .WORD    068h
   .WORD    I2_CC-CBASE

T2_DD:
   .WORD    068h
   .WORD    I2_DD-CBASE

T2_EE:
   .WORD    068h
   .WORD    I2_EE-CBASE

T2_FF:
   .WORD    068h
   .WORD    I2_FF-CBASE

T2_GG:
   .WORD    068h
   .WORD    I2_GG-CBASE

T2_HH:
   .WORD    068h
   .WORD    I2_HH-CBASE

T2_II:
   .WORD    028h
   .WORD    I2_II-CBASE

T2_JJ:
   .WORD    068h
   .WORD    I2_JJ-CBASE

T2_KK:
   .WORD    068h
   .WORD    I2_KK-CBASE

T2_LL:
   .WORD    058h
   .WORD    I2_LL-CBASE

T2_MM:
   .WORD    0A8h
   .WORD    I2_MM-CBASE

T2_NN:
   .WORD    078h
   .WORD    I2_NN-CBASE

T2_OO:
   .WORD    078h
   .WORD    I2_OO-CBASE

T2_PP:
   .WORD    068h
   .WORD    I2_PP-CBASE

T2_QQ:
   .WORD    07Ah
   .WORD    I2_QQ-CBASE

T2_RR:
   .WORD    068h
   .WORD    I2_RR-CBASE

T2_SS:
   .WORD    068h
   .WORD    I2_SS-CBASE

T2_TT:
   .WORD    068h
   .WORD    I2_TT-CBASE

T2_UU:
   .WORD    068h
   .WORD    I2_UU-CBASE

T2_VV:
   .WORD    078h
   .WORD    I2_VV-CBASE

T2_WW:
   .WORD    0B8h
   .WORD    I2_WW-CBASE

T2_XX:
   .WORD    078h
   .WORD    I2_XX-CBASE

T2_YY:
   .WORD    068h
   .WORD    I2_YY-CBASE

T2_ZZ:
   .WORD    068h
   .WORD    I2_ZZ-CBASE

; ===========================
; | CHARACTER DIRECTORY     |
; ===========================

SYSFONT:

   .BYTE    (T2_SP-T2_SP)/32		; SPACE CHARACTER, " "
   .BYTE    (T2_SP-T2_SP)/32		; FILLER
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_SP-T2_SP)/32
   .BYTE    (T2_MN-T2_SP)/32		; MINUS CHARACTER, "-"
   .BYTE    (T2_PER-T2_SP)/32
   .BYTE    (T2_SLASH-T2_SP)/32		; "/"
   .BYTE    (T2_00-T2_SP)/32		;0
   .BYTE    (T2_11-T2_SP)/32		;1
   .BYTE    (T2_22-T2_SP)/32		;2
   .BYTE    (T2_33-T2_SP)/32		;3
   .BYTE    (T2_44-T2_SP)/32		;4
   .BYTE    (T2_55-T2_SP)/32		;5
   .BYTE    (T2_66-T2_SP)/32		;6
   .BYTE    (T2_77-T2_SP)/32		;7
   .BYTE    (T2_88-T2_SP)/32		;8
   .BYTE    (T2_99-T2_SP)/32		;9
   .BYTE    (T2_00-T2_SP)/32			; no :
   .BYTE    (T2_00-T2_SP)/32			; no ;
   .BYTE    (T2_00-T2_SP)/32			; no <
   .BYTE    (T2_00-T2_SP)/32			; no =
   .BYTE    (T2_00-T2_SP)/32			; no >
   .BYTE    (T2_00-T2_SP)/32			; no ?
   .BYTE    (T2_00-T2_SP)/32			; no @
   .BYTE    (T2_AA-T2_SP)/32		;A
   .BYTE    (T2_BB-T2_SP)/32		;B
   .BYTE    (T2_CC-T2_SP)/32		;C
   .BYTE    (T2_DD-T2_SP)/32		;D
   .BYTE    (T2_EE-T2_SP)/32		;E
   .BYTE    (T2_FF-T2_SP)/32		;F
   .BYTE    (T2_GG-T2_SP)/32		;G
   .BYTE    (T2_HH-T2_SP)/32		;H
   .BYTE    (T2_II-T2_SP)/32		;I
   .BYTE    (T2_JJ-T2_SP)/32		;J
   .BYTE    (T2_KK-T2_SP)/32		;K
   .BYTE    (T2_LL-T2_SP)/32		;L
   .BYTE    (T2_MM-T2_SP)/32		;M
   .BYTE    (T2_NN-T2_SP)/32		;N
   .BYTE    (T2_OO-T2_SP)/32		;O
   .BYTE    (T2_PP-T2_SP)/32		;P
   .BYTE    (T2_QQ-T2_SP)/32		;Q
   .BYTE    (T2_RR-T2_SP)/32		;R
   .BYTE    (T2_SS-T2_SP)/32		;S
   .BYTE    (T2_TT-T2_SP)/32		;T
   .BYTE    (T2_UU-T2_SP)/32		;U
   .BYTE    (T2_VV-T2_SP)/32		;V
   .BYTE    (T2_WW-T2_SP)/32		;W
   .BYTE    (T2_XX-T2_SP)/32		;X
   .BYTE    (T2_YY-T2_SP)/32		;Y
   .BYTE    (T2_ZZ-T2_SP)/32		;Z

; ===========================
; | CHARACTER DEFINITIONS   |
; ===========================
CBASE:
I2_SP:
   .byte    00h
   .byte    00h
   .byte    00h
   .byte    00h
   .byte    00h
   .byte    00h
   .byte    00h
   .byte    00h

I2_MN:
   .byte    000h
   .byte    000h
   .byte    000h
   .byte    0FFh
   .byte    0FFh
   .byte    000h
   .byte    000h
   .byte    000h

I2_PER:
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0
	.BYTE	0FFH
	.BYTE	0FFH

I2_SLASH:
	.BYTE	30H
	.BYTE	30H
	.BYTE	18H
	.BYTE	18H
	.BYTE	06H
	.BYTE	06H
	.BYTE	03H
	.BYTE	03H

I2_00:
   .byte    01Eh
   .byte    03Fh
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    03Fh
   .byte    01Eh

I2_11:
   .byte    0Eh
   .byte    0Fh
   .byte    0Fh
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch

I2_22:
   .byte    01Fh
   .byte    03Fh
   .byte    038h
   .byte    01Ch
   .byte    0Eh
   .byte    07h
   .byte    03Fh
   .byte    03Fh

I2_33:
   .byte    01Fh
   .byte    03Fh
   .byte    030h
   .byte    01Eh
   .byte    01Eh
   .byte    030h
   .byte    03Fh
   .byte    01Fh

I2_44:
   .byte    038h
   .byte    03Ch
   .byte    036h
   .byte    033h
   .byte    03Fh
   .byte    03Fh
   .byte    030h
   .byte    030h

I2_55:
   .byte    03Fh
   .byte    03Fh
   .byte    03h
   .byte    01Fh
   .byte    03Fh
   .byte    030h
   .byte    03Fh
   .byte    01Fh

I2_66:
   .byte    03Eh
   .byte    03Fh
   .byte    03h
   .byte    01Fh
   .byte    03Fh
   .byte    033h
   .byte    03Fh
   .byte    01Eh

I2_77:
   .byte    03Fh
   .byte    03Fh
   .byte    030h
   .byte    018h
   .byte    018h
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch

I2_88:
   .byte    01Eh
   .byte    03Fh
   .byte    033h
   .byte    01Eh
   .byte    01Eh
   .byte    033h
   .byte    03Fh
   .byte    01Eh

I2_99:
   .byte    01Eh
   .byte    03Fh
   .byte    033h
   .byte    03Fh
   .byte    03Eh
   .byte    030h
   .byte    03Fh
   .byte    01Fh

I2_AA:
   .byte    01Eh
   .byte    03Fh
   .byte    033h
   .byte    033h
   .byte    03Fh
   .byte    03Fh
   .byte    033h
   .byte    033h

I2_BB:
   .byte    01Fh
   .byte    03Fh
   .byte    033h
   .byte    03Fh
   .byte    01Fh
   .byte    033h
   .byte    03Fh
   .byte    01Fh

I2_CC:
   .byte    03Eh
   .byte    03Fh
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03Fh
   .byte    03Eh

I2_DD:
   .byte    01Fh
   .byte    03Fh
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    03Fh
   .byte    01Fh

I2_EE:
   .byte    03Fh
   .byte    03Fh
   .byte    03h
   .byte    03Fh
   .byte    03Fh
   .byte    03h
   .byte    03Fh
   .byte    03Fh

I2_FF:
   .byte    03Fh
   .byte    03Fh
   .byte    03h
   .byte    03Fh
   .byte    03Fh
   .byte    03h
   .byte    03h
   .byte    03h

I2_GG:
   .byte    03Eh
   .byte    03Fh
   .byte    03h
   .byte    03h
   .byte    033h
   .byte    033h
   .byte    03Fh
   .byte    01Eh

I2_HH:
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    03Fh
   .byte    03Fh
   .byte    033h
   .byte    033h
   .byte    033h

I2_II:
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h

I2_JJ:
   .byte    030h
   .byte    030h
   .byte    030h
   .byte    030h
   .byte    030h
   .byte    033h
   .byte    03Fh
   .byte    01Eh

I2_KK:
   .byte    033h
   .byte    033h
   .byte    01Bh
   .byte    0Fh
   .byte    01Fh
   .byte    033h
   .byte    033h
   .byte    033h

I2_LL:
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    03h
   .byte    01Fh
   .byte    01Fh

I2_MM:
   .byte    087h,03h
   .byte    0CFh,03h
   .byte    0CFh,03h
   .byte    07Bh,03h
   .byte    07Bh,03h
   .byte    033h,03h
   .byte    033h,03h
   .byte    033h,03h

I2_NN:
   .byte    063h
   .byte    067h
   .byte    06Fh
   .byte    06Fh
   .byte    07Bh
   .byte    07Bh
   .byte    073h
   .byte    063h

I2_OO:
   .byte    03Eh
   .byte    07Fh
   .byte    063h
   .byte    063h
   .byte    063h
   .byte    063h
   .byte    07Fh
   .byte    03Eh

I2_PP:
   .byte    01Fh
   .byte    03Fh
   .byte    033h
   .byte    03Fh
   .byte    01Fh
   .byte    03h
   .byte    03h
   .byte    03h

I2_QQ:
   .byte    03Eh
   .byte    07Fh
   .byte    063h
   .byte    063h
   .byte    063h
   .byte    063h
   .byte    07Fh
   .byte    03Eh
   .byte    060h
   .byte    060h

I2_RR:
   .byte    01Fh
   .byte    03Fh
   .byte    033h
   .byte    03Fh
   .byte    01Fh
   .byte    033h
   .byte    033h
   .byte    033h

I2_SS:
   .byte    03Eh
   .byte    03Fh
   .byte    03h
   .byte    01Fh
   .byte    03Eh
   .byte    030h
   .byte    03Fh
   .byte    01Fh

I2_TT:
   .byte    03Fh
   .byte    03Fh
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch

I2_UU:
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    033h
   .byte    03Fh
   .byte    01Eh

I2_VV:
   .byte    063h
   .byte    063h
   .byte    063h
   .byte    036h
   .byte    036h
   .byte    03Eh
   .byte    01Ch
   .byte    01Ch

I2_WW:
   .byte    023h,06h
   .byte    023h,06h
   .byte    073h,06h
   .byte    076h,03h
   .byte    076h,03h
   .byte    0DEh,03h
   .byte    08Ch,01h
   .byte    08Ch,01h

I2_XX:
   .byte    063h
   .byte    063h
   .byte    036h
   .byte    01Ch
   .byte    01Ch
   .byte    036h
   .byte    063h
   .byte    063h

I2_YY:
   .byte    033h
   .byte    033h
   .byte    01Eh
   .byte    01Eh
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch
   .byte    0Ch

I2_ZZ:
   .byte    03Fh
   .byte    03Fh
   .byte    038h
   .byte    01Ch
   .byte    0Eh
   .byte    07h
   .byte    03Fh
   .byte    03Fh

	.END
